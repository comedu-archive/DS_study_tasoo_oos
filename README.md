# **3~4주차 과제 안내**

## 기본 과제: 이진 탐색 트리 (BST) 구현 상세 가이드

### 이진 탐색 트리 (BST) 이해하기

이진 탐색 트리(BST)는 각 노드가 최대 두 개의 자식을 가지는 트리 데이터 구조입니다. 각 노드는 키(또는 데이터)를 포함하며, 키들은 정렬된 순서로 저장됩니다:

- **왼쪽 자식**: 왼쪽 자식의 키는 부모 노드의 키보다 작습니다.
- **오른쪽 자식**: 오른쪽 자식의 키는 부모 노드의 키보다 큽니다.
- **루트 노드**: 트리의 최상위 노드로, 트리가 여기서 시작됩니다.

### BST 노드의 기본 구조
```c
typedef struct node {
    int key;
    struct node *left;
    struct node *right;
} Node;
```

### 구현 요점
1. **삽입**: 새로운 키를 삽입할 때, 루트에서 시작하여 올바른 위치를 찾기 위해 키들을 비교합니다.
2. **검색**: 루트에서 시작하여 원하는 노드를 찾기 위해 아래로 이동하며 키들을 비교합니다.
3. **삭제**: 리프 노드 삭제, 한 자식을 가진 노드 삭제, 두 자식을 가진 노드 삭제의 세 가지 경우를 다뤄야 합니다.

### C/C++에서 BST 구현하기
- `Node` 구조체를 정의하여 키, 왼쪽 및 오른쪽 포인터를 포함시킵니다.
- 삽입, 검색, 삭제를 위한 재귀 함수를 구현합니다.
- 트리를 순회하는 유틸리티 함수(중위, 전위, 후위 순회)를 작성합니다.

### 관련 자료
- BST 개념 설명: [BST Wikipedia](https://en.wikipedia.org/wiki/Binary_search_tree)
- 심층 BST 가이드: [Geeks for Geeks BST](https://www.geeksforgeeks.org/binary-search-tree-data-structure/)


## 고급 과제: 최대 힙 구현 및 BST로의 변환 상세 가이드

### 최대 힙(Max Heap) 이해하기

최대 힙은 트리가 완전하고 모든 노드가 힙 속성을 따르는 이진 트리의 특별한 경우입니다:

- **힙 속성**: 최대 힙에서 부모의 키는 그 자식들의 키보다 크거나 같습니다.
- **완전 트리**: 트리의 모든 레벨이 완전히 채워져 있으며, 마지막 레벨만 왼쪽부터 차례대로 채워질 수 있습니다.

### 힙 노드의 기본 구조
최대 힙에서 트리는 대체로 배열로 표현됩니다. 배열 표현은 공간 효율적이며 부모-자식 관계를 단순화합니다:

- **부모 노드**: 주어진 노드가 인덱스 `i`에 있을 때, 그 부모는 인덱스 `(i-1)/2`에 있습니다.
- **왼쪽 자식**: 인덱스 `i`의 노드의 왼쪽 자식은 `2*i + 1`에 있습니다.
- **오른쪽 자식**: 인덱스 `i`의 노드의 오른쪽 자식은 `2*i + 2`에 있습니다.

### 관련 자료
- 최대 힙 개념 설명: [Max Heap Wikipedia](https://en.wikipedia.org/wiki/Binary_heap)
- 최대 힙 심층 가이드: [Max Heap Geeks for Geeks](https://www.geeksforgeeks.org/convert-max-heap-to-min-heap-in-linear-time/)

---

📚 **추가 학습 자료**:
- 이 구조들에 대한 보다 시각적인 이해를 위해 [VisuAlgo](https://visualgo.net/en)와 같은 간지나는 웹사이트를 추천합니다.
- [백준](https://www.acmicpc.net/)과 같은 코딩 플랫폼에서 이 주제에 대한 연습 문제를 제공합니다.
- 이전 과제에 대한 내용은 queue 폴더 내에 있습니다.

Written by ChatGPT

개꿀